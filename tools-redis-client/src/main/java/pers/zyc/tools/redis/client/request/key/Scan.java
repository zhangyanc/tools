package pers.zyc.tools.redis.client.request.key;

import pers.zyc.tools.redis.client.request.BaseScan;
import pers.zyc.tools.redis.client.util.ByteUtil;

/**
 * SCAN cursor [MATCH pattern] [COUNT count]
 * </p>
 *
 * SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素：
 * <ul>
 *     <li>SCAN 命令用于迭代当前数据库中的数据库键。</li>
 *     <li>SSCAN 命令用于迭代集合键中的元素。</li>
 *     <li>HSCAN 命令用于迭代哈希键中的键值对。</li>
 *     <li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</li>
 * </ul>
 * </p>
 *
 * 以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素，所以这些命令可以用于生产环境， 而不会出现像 KEYS 命
 * 令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集
 * 合键时， 它们可能会阻塞服务器达数秒之久。
 * </p>
 *
 * 因为 SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令， 但是要记住：
 * <ul>
 *     <li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</li>
 *     <li>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</li>
 * </ul>
 * </p>
 *
 * SCAN 命令的基本用法：
 * SCAN 命令是一个基于游标的迭代器（cursor based iterator），SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在
 * 下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。
 * 当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。
 * </p>
 *
 * SCAN 命令的保证（guarantees）：
 * SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间，
 * 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的
 * 数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。
 *
 * 然而因为增量式命令仅仅使用游标来记录迭代状态， 所以这些命令带有以下缺点：
 * <ul>
 *     <li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说，可以考虑将迭代返回的元素仅仅用于可以安全
 *     		地重复执行多次的操作上。
 *     </li>
 *     <li>
 *         如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也
 *         可能不会， 这是未定义的（undefined）。
 *     </li>
 * </ul>
 * </p>
 *
 * SCAN 命令每次执行返回的元素数量：
 * 增量式迭代命令并不保证每次执行都返回某个给定数量的元素。
 * 增量式命令甚至可能会返回零个元素， 但只要命令返回的游标不是 0 ， 应用程序就不应该将迭代视作结束。
 * 不过命令返回的元素数量总是符合一定规则的， 在实际中：
 * <ul>
 *     <li>对于一个大数据集来说， 增量式迭代命令每次最多可能会返回数十个元素；</li>
 *     <li>而对于一个足够小的数据集来说， 如果这个数据集的底层表示为编码数据结构（encoded data structure，适用于是小集合键、小
 *     		哈希键和小有序集合键）， 那么增量迭代命令将在一次调用中返回数据集中的所有元素。
 *     </li>
 * </ul>
 * 最后， 用户可以通过增量式迭代命令提供的 COUNT 选项来指定每次迭代返回元素的最大值。
 * </p>
 *
 * COUNT 选项：
 * 虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 COUNT 选项， 对命令的行为进行一定程度上的调整。
 * 基本上， COUNT 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。
 * 虽然 COUNT 选项只是对增量式迭代命令的一种提示（hint）， 但是在大多数情况下， 这种提示都是有效的。
 * <ul>
 *     <li>COUNT 参数的默认值为 10 。</li>
 *     <li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 MATCH 选项， 那么命令返回
 *     		的元素数量通常和 COUNT 选项指定的一样， 或者比 COUNT 选项指定的数量稍多一些。
 *     </li>
 *     <li>
 *         在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈
 *         希或者一个小有序集合）时， 增量式迭代命令通常会无视 COUNT 选项指定的值， 在第一次迭代就将数据集包含的所有元素都返回给
 *         用户。
 *     </li>
 * </ul>
 * 并非每次迭代都要使用相同的 COUNT 值。
 * 用户可以在每次迭代中按自己的需要随意改变 COUNT 值， 只要记得将上次迭代返回的游标用到下次迭代里面就可以了。
 * </p>
 *
 * MATCH 选项：
 * 和 KEYS 命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以
 * 通过在执行增量式迭代命令时， 通过给定 MATCH <pattern> 参数来实现。
 * 需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭
 * 代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。
 * </p>
 *
 * 并发执行多个迭代：
 * 在同一时间， 可以有任意多个客户端对同一数据集进行迭代， 客户端每次执行迭代都需要传入一个游标，并在迭代执行之后获得一个新
 * 的游标， 而这个游标就包含了迭代的所有状态， 因此， 服务器无须为迭代记录任何状态。
 * </p>
 *
 * 中途停止迭代：
 * 因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进
 * 行任何通知。
 * 即使有任意数量的迭代在中途停止， 也不会产生任何问题。
 * </p>
 *
 * 使用错误的游标进行增量式迭代：
 * 使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义
 * 的行为。
 * 未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。
 * 只有两种游标是合法的：
 * <ul>
 *     <li>在开始一个新的迭代时， 游标必须为 0 。</li>
 *     <li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。</li>
 * </ul>
 * </p>
 *
 * 迭代终结的保证：
 * 增量式迭代命令所使用的算法只保证在数据集的大小有界（bounded）的情况下， 迭代才会停止， 换句话说， 如果被迭代数据集的大
 * 小不断地增长的话， 增量式迭代命令可能永远也无法完成一次完整迭代。
 * 从直觉上可以看出， 当一个数据集不断地变大时， 想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决
 * 于用户执行迭代的速度是否比数据集增长的速度更快。
 * </p>
 *
 * <ul>
 * <li>时间复杂度: 增量式迭代命令每次执行的复杂度为 O(1) ，对数据集进行一次完整迭代的复杂度为 O(N) ，其中 N 为数据集中的元素数
 * 		量。</li>
 * <li>Redis版本要求: >=2.8.0</li>
 * <li>返回值:
 * 		SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复：
 * 		回复的第一个元素是字符串表示的无符号 64 位整数（游标）， 回复的第二个元素是另一个 multi-bulk 回复，
 * 		这个 multi-bulk 回复包含了本次被迭代的元素。
 *
 * 		SCAN 命令返回的每个元素都是一个数据库键。
 * 		SSCAN 命令返回的每个元素都是一个集合成员。
 * 		HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。
 * 		ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。
 * </li>
 * </ul>
 *
 * @author zhangyancheng
 */
public class Scan extends BaseScan {

	public Scan(long cursor) {
		super(
				ByteUtil.toByteArray(cursor)
		);
	}

	public Scan(long cursor, String match) {
		super(
				ByteUtil.toByteArray(cursor),
				ByteUtil.toByteArray("MATCH"),
				ByteUtil.toByteArray(match)
		);
	}

	public Scan(long cursor, int count) {
		super(
				ByteUtil.toByteArray(cursor),
				ByteUtil.toByteArray("COUNT"),
				ByteUtil.toByteArray(count)
		);
	}

	public Scan(long cursor, String match, int count) {
		super(
				ByteUtil.toByteArray(cursor),
				ByteUtil.toByteArray("MATCH"),
				ByteUtil.toByteArray(match),
				ByteUtil.toByteArray("COUNT"),
				ByteUtil.toByteArray(count)
		);
	}
}
